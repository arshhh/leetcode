class Solution {
public:
 bool isPalindrome(string s,int i, int j){
        while(j>i){
			if(s[j] == s[i]){
				i++;
				j--;
			}
else{
	return false;
}	
		}
		return true;
	}

    bool** getPalindromeTable(string s){
        int n=s.size();
        //table[i][j] means s[i][j] is palindrome or not
        
        bool** table=new bool*[n];
        for(int i=0;i<n;i++)
            table[i]=new bool[n];
        for(int len=1;len<=n;len++){
            for(int i=0;i+len-1<n;i++){
                int end=i+len-1;
                if(len==1)
                    table[i][end]=true;
                else{
                    if(s[i]!=s[end])
                        table[i][end]=false;
                    else{
                        if(i+1<=end-1){
                            table[i][end] = table[i+1][end-1];
                        }else
                            table[i][end] = true;
                    }
                }
            }
        }//for
        return table;
        
    }
    int minCut(string s) {
        // Start typing your C/C++ solution below
        // DO NOT write int main() function
    int n=s.size();
	//dp[i] min cuts between s[i..n) dp[0] is what we want
	int dp[n+1];
	for(int i=0;i<n+1;i++)
		dp[i]=n+1;
	dp[n]=-1;
	dp[n-1]=0;
    //build palindrome table
    
    bool ** table=getPalindromeTable(s);
	//test s[i...n) 
	for(int i=n-2;i>-1;i--){
        if(isPalindrome(s,i,n-1)){
            dp[i]=0;
            continue;
        }
		for(int k=n-2;k>=i;k--){
			//test if s[i...k] is a palindrome
			if(table[i][k]){
				dp[i]=min(dp[i],1+dp[k+1]);      
			}
		}
	}//for
	return dp[0];
    }
};

