class Solution {
public:
    int findMinIndex(vector<int> &prices, int startIndex,int endIndex){
    	int minIndex = startIndex;
	for(int i=startIndex+1;i<=endIndex;i++){
		if(prices[i]<prices[minIndex])
			minIndex = i;
	}
	return minIndex;
    }
    
    int findMaxIndex(vector<int> &prices, int startIndex,int endIndex){
	int maxIndex = startIndex;
	for(int i=startIndex+1;i<=endIndex;i++){
		if(prices[i] >prices[maxIndex])
			maxIndex = i;
    	}
	return maxIndex;
    }
	int getMax(int i,int j){
		return i >j ? i : j;
	}
	//get the maximum profit between startIndex and endIndex of prices if if you have only one change to trade
	//you shoud use dynamic programmming to address this problem, store and update the minimum price between
	//[i,j]
	//max[i,j] = prices[j]-min[i,j-1] > max[i,j-1] ? price...... : max[i,j-1]
   	int getProfit(vector<int> &prices,int startIndex,int endIndex) {
	 // Start typing your C/C++ solution below
	 // DO NOT write int main() function
	if(startIndex>endIndex)
		return 0;
	int min=prices[startIndex];
	max =0;
	for(int i=startIndex+1;i<=endIndex;i++){
		if(prices[i]-min>max){
			max = prices[i]-min;
		}
		//update min
		if(prices[i]<min)
			min=prices[i];
	}
	return max;
}

    int maxProfit(vector<int> &prices) {
        // Start typing your C/C++ solution below
        // DO NOT write int main() function
            int size = prices.size();
            int profit = 0;
                int startIndex = 0;
	for(int i=startIndex+1;i<size;i++){
		if(prices.at(i)<=prices.at(startIndex))
			startIndex = i;
		else
			break;
	}
    	for(int i=startIndex;i<size;i++){
		int profit1 = getProfit(prices,startIndex,i-1);
		int profit2 = getProfit(prices,i,size-1);
		profit = getMax(profit, profit1+profit2);
	}
	return profit;

    }
};
